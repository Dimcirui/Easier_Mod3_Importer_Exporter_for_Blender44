# -*- coding: utf-8 -*-
"""
Created on Thu Mar 14 00:14:32 2019

@author: AsteriskAmpersand
"""

import bpy
import math
import re
import os
import sys
from bpy_extras.io_utils import ExportHelper
from bpy.props import EnumProperty, BoolProperty, StringProperty
from bpy.types import Operator
from mathutils import Vector, Euler, Matrix

from ..mod3 import Mod3ExporterLayer as Mod3EL
from ..blender import BlenderMod3Exporter as Api
from ..blender.BlenderSupressor import SupressBlenderOps

class Context():
    def __init__(self, path, meshes, armature):
        self.path = path

class ExportMOD3(Operator, ExportHelper):
    bl_idname = "custom_export.export_mhw_mod3"
    bl_label = "Save MHW MOD3 file (.mod3)"
    bl_options = {'REGISTER', 'PRESET', 'UNDO'}
 
    # ImportHelper mixin class uses this
    filename_ext = ".mod3"
    filter_glob: StringProperty(default="*.mod3", options={'HIDDEN'}, maxlen=255)

    split_normals: BoolProperty(
        name = "Use Custom Normals",
        description = "Use split/custom normals instead of Blender autogenerated normals.",
        default = True)
    highest_lod: BoolProperty(
        name = "Set Meshparts to Highest LOD",
        description = "Overwrites all meshparts' explicit LODs to the highest LOD.",
        default = True)
    coerce_fourth: BoolProperty(
        name = "Coerce 4th Negative Weight",
        description = "Forces non-explicit 4 weight vertices into a 4 weight blocktype.",
        default = True)
    
    errorItems = [("Ignore","Ignore","Will not log warnings. Catastrophical errors will still break the process.",0),
                  ("Warning","Warning","Will be logged as a warning. This are displayed in the console. (Window > Toggle_System_Console)",1),
                  ("Error","Error","Will stop the exporting process. An error will be displayed and the log will show details. (Window > Toggle_System_Console)",2),
                  ]
    levelProperties = ["propertyLevel","blocktypeLevel","loopLevel","uvLevel","colourLevel","weightLevel","weightCountLevel"]
    levelNames = ["Property Error Level", "Blocktype Error Level", "Loops Error Level", "UV Error Level", "Colour Error Level", "Weighting Error Level", "Weight Count Error Level"]
    levelDescription = ["Missing and Duplicated Header Properties",
                        "Conflicting Blocktype Declarations",
                        "Redundant, Mismatched and Missing Normals",
                        "UV Map Incompatibilities",
                        "Colour Map Incompatibilities",
                        "Vertex Weight Groups Irregularities",
                        "Weight Count Errors"]
    levelDefaults = ["Warning","Error","Ignore","Error","Ignore","Warning","Warning","Error"]
    propString = """EnumProperty(
                    name = name,
                    description = desc,
                    items = errorItems,
                    default = pred,                
                    )"""
    for prop,name,desc,pred in zip(levelProperties, levelNames, levelDescription, levelDefaults):
        exec("%s : %s"%(prop, propString))

    def execute(self,context):
        sel_type = sorted([o.type for o in bpy.context.selected_objects])
        if "MESH" not in sel_type or "ARMATURE" not in sel_type:
            raise Exception("You must select meshes and only one armature to export MOD3!!! ")
        ar_name = sorted([o.name for o in bpy.context.selected_objects if o.type=="ARMATURE"])
        if len(ar_name)>1:
            raise Exception("You must select meshes and only one armature to export MOD3!!! ")
        
        sel_name = armature_to_emptys()
        empty_sel_name = sorted([o.name for o in bpy.context.selected_objects if o.type=="EMPTY"])
        BApi = Api.BlenderExporterAPI()
        with SupressBlenderOps():
            try:
                bpy.ops.object.mode_set(mode='OBJECT')
            except:
                pass
            bpy.ops.object.select_all(action='DESELECT')
            for n in sel_name:
                if bpy.data.objects[n].type == "MESH":
                    bpy.ops.object.select_pattern(pattern=n, case_sensitive=False, extend=True)  
            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
            bpy.ops.object.select_all(action='DESELECT')

        for n in sel_name:
            bpy.ops.object.select_pattern(pattern=n, case_sensitive=False, extend=True)
             
        options = self.parseOptions()
        Mod3EL.ModelToMod3(BApi, options).execute(self.properties.filepath)

        bpy.ops.object.select_all(action='DESELECT')
        for n in empty_sel_name:
            bpy.ops.object.select_pattern(pattern=n, case_sensitive=False, extend=True)
        bpy.ops.object.delete(use_global=False)
        
        bpy.context.view_layer.objects.active = bpy.data.objects[ar_name[0]]   
        bpy.context.active_object.scale = (0.010,0.010,0.010)
        bpy.context.active_object.rotation_euler = (1.5708,0,0)   
   
        with SupressBlenderOps():
            bpy.ops.object.select_all(action='DESELECT')
            for ob in bpy.context.selected_objects:
                ob.select = False
        #bpy.ops.object.mode_set(mode='OBJECT')
        #bpy.context.area.type = 'INFO'
        return {'FINISHED'}
    
    def parseOptions(self):
        options = {
                "lod":self.highest_lod,
                "levels":{prop:self.__getattribute__(prop) for prop in self.levelProperties},
                "splitnormals":self.split_normals,
                "coerce":self.coerce_fourth,
                }        
        return options
    
def menu_func_export(self, context):
    self.layout.operator(ExportMOD3.bl_idname, text="MHW MOD3 (.mod3)")

def vec_roll_to_mat3(vec, roll):
    target = Vector((0, 0.1, 0))
    nor = vec.normalized()
    axis = target.cross(nor)
    if axis.dot(axis) > 0.0000000001: # this seems to be the problem for some bones, no idea how to fix
        axis.normalize()
        theta = target.angle(nor)
        bMatrix = Matrix.Rotation(theta, 3, axis)
    else:
        updown = 1 if target.dot(nor) > 0 else -1
        bMatrix = Matrix.Scale(updown, 3)               
        bMatrix[2][2] = 1.0

    rMatrix = Matrix.Rotation(roll, 3, nor)
    mat = rMatrix @ bMatrix
    return mat

def armature_to_emptys():
    bpy.ops.object.mode_set(mode='OBJECT')
        
    meshes_sel_name = sorted([o.name for o in bpy.context.selected_objects if o.type == "MESH"]) 
    for o in bpy.context.selected_objects:
        if o.type == "ARMATURE":
             armature_sel_name = o.name

    #print(armature_sel_name)    
    bpy.context.view_layer.objects.active = bpy.data.objects[armature_sel_name]   
    bpy.context.active_object.scale = 100*bpy.context.active_object.scale
    bpy.context.active_object.rotation_euler[0] = bpy.context.active_object.rotation_euler[0] - 1.5708
    bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
    ArmatureName = bpy.context.active_object.data.name
    obj = bpy.context.active_object.data.bones 
    bones_name = ['']*len(obj)
    for i in range(len(obj)):
        bones_name[i] = obj[i].name
    #print(bones_name)
    bpy.ops.object.mode_set(mode='EDIT')
  
    for n in bones_name:
        b = bpy.data.armatures[ArmatureName].edit_bones[n]
        
        empty = bpy.data.objects.new(n, None)
        bpy.context.collection.objects.link(empty)
        
        
        if b.parent:
            vec = b.tail - b.head
            roll = b.roll
            mat3 = vec_roll_to_mat3(vec, roll)
            mat4 = mat3.to_4x4()
            #print(mat4)
            empty.parent = bpy.data.objects.get(b.parent.name)
            empty.matrix_world = mat4
            empty.matrix_world[0][3] = b.matrix[0][3]
            empty.matrix_world[1][3] = b.matrix[1][3]
            empty.matrix_world[2][3] = b.matrix[2][3]
            #print(empty.matrix_world)
            
            #print(b["boneFunction"],b["unkn2"])
            bf = re.findall(r'\d+',b.name)
            empty["boneFunction"] = int(bf[0])
            empty["unkn2"] = b["unkn2"]
        else: 
            matrix_final = b.matrix
            #empty.name = ArmatureName
            empty.matrix_world = matrix_final
            #print(matrix_final)
    
    
    bpy.ops.object.mode_set(mode='OBJECT')  
    
    for n in bones_name:
        c = bpy.data.armatures[ArmatureName].bones[n]  
        #print(c["boneFunction"])
        if "child" in c.keys():
            bpy.context.view_layer.objects.active = bpy.data.objects[n]
            bpy.ops.object.constraint_add(type='CHILD_OF')
            bpy.context.object.constraints[0].use_location_x = False
            bpy.context.object.constraints[0].use_rotation_x = False
            bpy.context.object.constraints[0].use_scale_x = False
            bpy.context.object.constraints[0].use_location_y = False
            bpy.context.object.constraints[0].use_rotation_y = False
            bpy.context.object.constraints[0].use_scale_y = False
            bpy.context.object.constraints[0].use_location_z = False
            bpy.context.object.constraints[0].use_rotation_z = False
            bpy.context.object.constraints[0].use_scale_z = False

            if c["child"] == 255:
                constraint_name = bpy.context.object.constraints[0].name
                bpy.ops.constraint.delete(constraint=constraint_name, owner='OBJECT')
            else:
                if "bonefunction_%03d"%(c["child"]) not in bones_name:
                    constraint_name = bpy.context.object.constraints[0].name
                    bpy.ops.constraint.delete(constraint=constraint_name, owner='OBJECT')
                else:
                    bpy.context.object.constraints[0].target = bpy.data.objects["bonefunction_%03d"%(c["child"])]  
                
                
    bpy.ops.object.select_all(action='DESELECT')
    
    for n in bones_name:
        if bpy.data.objects[n].type == "EMPTY":
            bpy.ops.object.select_pattern(pattern=n, case_sensitive=False, extend=True)
    for n in meshes_sel_name:
        bpy.ops.object.select_pattern(pattern=n, case_sensitive=False, extend=True)
        
    sel_name = sorted([o.name for o in bpy.context.selected_objects if o.type=="MESH" or "EMPTY"])
    #print(sel_name)
    return sel_name